name: Issues Housekeeping (ucflow)

on:
  schedule:
    # üéØ Chaque dimanche √† 11:00 heure de Paris (DST inclus)
    # √ât√© (Paris UTC+2)  => 09:00 UTC
    # Hiver (Paris UTC+1)=> 10:00 UTC
    - cron: "0 9 * * 0"
    - cron: "0 10 * * 0"
  workflow_dispatch:
    inputs:
      close_older_than_days:
        description: "Fermer automatiquement les issues ucflow plus vieilles que X jours"
        required: true
        default: "14"
      enable_delete:
        description: "Activer la suppression (DANGEREUX). true/false"
        required: true
        default: "false"
      delete_older_than_days:
        description: "Supprimer (si enable_delete=true) les issues ucflow plus vieilles que Y jours"
        required: true
        default: "180"
      dry_run:
        description: "Dry-run (aucun changement). true/false"
        required: true
        default: "true"

permissions:
  issues: write
  contents: read

jobs:
  housekeeping:
    runs-on: ubuntu-latest

    # ‚úÖ Evite les collisions avec d'autres workflows
    concurrency:
      group: ucflow-maintenance
      cancel-in-progress: false

    steps:
      - name: Guard ‚Äî uniquement dimanche 11:00 Paris (schedule) / toujours OK en manuel
        if: ${{ github.event_name == 'schedule' }}
        run: |
          HHMM=$(TZ="Europe/Paris" date +"%H%M")
          DOW=$(TZ="Europe/Paris" date +"%u") # 1..7 (7=Dimanche)
          echo "Paris HHMM: ${HHMM} | DOW: ${DOW}"

          if [ "${DOW}" != "7" ]; then
            echo "‚è≠Ô∏è Pas dimanche ‚Üí stop."
            exit 0
          fi

          if [ "${HHMM}" != "1100" ]; then
            echo "‚è≠Ô∏è Pas 11:00 Paris ‚Üí stop (run technique DST)."
            exit 0
          fi

      - name: Housekeeping ucflow issues (close + optional delete)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          EVENT_NAME: ${{ github.event_name }}
          # ‚úÖ Par d√©faut (schedule): close √† 14 jours, delete √† 180 jours
          CLOSE_DAYS_DEFAULT: "14"
          DELETE_DAYS_DEFAULT: "180"
        run: |
          set -euo pipefail

          python << 'PY'
          import os, json, urllib.request, urllib.error
          from datetime import datetime, timezone

          repo = os.environ["REPO"]
          token = os.environ["GH_TOKEN"]
          event_name = os.environ["EVENT_NAME"]

          def get_input(name: str, default: str) -> str:
            key = f"INPUT_{name.upper()}"
            return os.environ.get(key, default)

          close_days = int(get_input("close_older_than_days", os.environ["CLOSE_DAYS_DEFAULT"]))
          enable_delete = get_input("enable_delete", "false").strip().lower() == "true"
          delete_days = int(get_input("delete_older_than_days", os.environ["DELETE_DAYS_DEFAULT"]))
          dry_run = get_input("dry_run", "true").strip().lower() == "true"

          label = "ucflow"
          now = datetime.now(timezone.utc)

          print("=== UCFlow Issues Housekeeping ===")
          print(f"Repo: {repo}")
          print(f"Label: {label}")
          print(f"Mode: event={event_name} | dry_run={dry_run}")
          print(f"Close issues older than: {close_days} days")
          print(f"Delete enabled: {enable_delete}")
          print(f"Delete issues older than: {delete_days} days (only if enabled)")
          print("==================================")

          def request_json(url, method="GET", data=None):
            headers = {
              "Authorization": f"Bearer {token}",
              "Accept": "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": "ucflow-housekeeping",
            }
            req = urllib.request.Request(url, headers=headers, method=method)
            if data is not None:
              req.data = data
            with urllib.request.urlopen(req) as r:
              return json.loads(r.read().decode("utf-8"))

          def patch_issue(number: int, payload: dict):
            url = f"https://api.github.com/repos/{repo}/issues/{number}"
            data = json.dumps(payload).encode("utf-8")
            return request_json(url, method="PATCH", data=data)

          def list_issues():
            issues = []
            page = 1
            while True:
              url = (
                f"https://api.github.com/repos/{repo}/issues"
                f"?state=all&labels={label}&per_page=100&page={page}"
              )
              batch = request_json(url)
              batch = [i for i in batch if "pull_request" not in i]
              if not batch:
                break
              issues.extend(batch)
              page += 1
            return issues

          def graphql(query: str, variables: dict):
            url = "https://api.github.com/graphql"
            payload = json.dumps({"query": query, "variables": variables}).encode("utf-8")
            headers = {
              "Authorization": f"Bearer {token}",
              "Accept": "application/vnd.github+json",
              "User-Agent": "ucflow-housekeeping",
            }
            req = urllib.request.Request(url, headers=headers, method="POST", data=payload)
            with urllib.request.urlopen(req) as r:
              return json.loads(r.read().decode("utf-8"))

          def delete_issue(node_id: str):
            query = """
              mutation($id: ID!) {
                deleteIssue(input: {issueId: $id}) {
                  clientMutationId
                }
              }
            """
            return graphql(query, {"id": node_id})

          issues = list_issues()
          print(f"Found {len(issues)} issue(s) with label '{label}'")

          to_close = []
          to_delete = []

          for it in issues:
            created_at = datetime.fromisoformat(it["created_at"].replace("Z", "+00:00"))
            age_days = (now - created_at).days
            state = it["state"].lower()
            number = it["number"]
            title = (it.get("title") or "")[:80]

            if state == "open" and age_days >= close_days:
              to_close.append((number, age_days, title))

            # ‚úÖ Suppression: uniquement si activ√©e + uniquement issues ferm√©es + tr√®s anciennes
            if enable_delete and state == "closed" and age_days >= delete_days:
              node_id = it.get("node_id")
              if node_id:
                to_delete.append((number, age_days, title, node_id))

          print(f"Candidates to close:  {len(to_close)}")
          print(f"Candidates to delete: {len(to_delete)}")

          for number, age_days, title in to_close:
            print(f"[CLOSE] #{number} ({age_days}d) {title}")
            if dry_run:
              continue
            patch_issue(number, {"state": "closed"})

          if enable_delete:
            for number, age_days, title, node_id in to_delete:
              print(f"[DELETE] #{number} ({age_days}d) {title}")
              if dry_run:
                continue
              try:
                resp = delete_issue(node_id)
                if "errors" in resp:
                  print("  ‚ö†Ô∏è GraphQL errors:", resp["errors"])
              except urllib.error.HTTPError as e:
                print("  ‚ùå Delete failed:", e.read().decode("utf-8"))

          print("‚úÖ Done.")
          PY
